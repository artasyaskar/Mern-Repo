task_description: |
  Task: Calendar intelligence - ISO weeks and business-day metrics
  Instructions:
  Create fresh endpoints to calculate ISO week details - handle summaries across dates - but check everything tightly. Use straightforward rules so info fits what’s expected each time.
  Requirements (as tested):
  - POST /adv/date-metrics
    Body (JSON): {
      start: dates displayed like 2023-10-15,
      completion day: a date shown like 2023-12-31
      Grab time off - skip add-ons; jot down days like 2025-12-25, repeat if needed
    }
    Behavior:
    - Check what showed up. Remove it unless it’s useful
    - some dates aren't written as year-month-day, also might not fit any actual calendar at all
      start → end
      vacation days shown using a simpler format instead of full dates like YYYY-MM-DD
      {"instruction": "Work out what's needed, then reply with a JSON containing these fields:"}
    - D-days overall stands for the complete number of days start to end, counting both the opening day along with the final one
    - business_days: tallies workdays from Monday to Friday within the span, skipping any dates flagged as holidays
    - weeks_iso: a list of different ISO week codes over time, like ["2025-W01"], arranged from earliest to latest
    - start_of_week: that’s the Monday (YYYY-MM-DD) in the ISO week holding start
      Sunday marks the week's close (YYYY-MM-DD), tied to the ISO period it lands in

  - GET /adv/iso-week
    Query: date=YYYY-MM-DD
    Behavior:
    Check the date - wrong one? Send back a 400.
    { "isoYear": number, yet "isoWeek": number, plus "label": "YYYY-Www" } based on ISO-8601 rules - weeks start every Monday.

  Notes:
  - Adjust these files: server/routes/advanced.js, while at it look into server/utils/date.js. Make sure everything runs smooth, so tests don’t fail.
  - Rules against cheating (need to stick to these):
    - Use basic methods instead of fixed answers for test dates.
    - Skip using lists tied to test inputs or jumps that give set answers for familiar dates.
    Your logic needs to handle any correct date from 1900 to 2100 without changes - so it runs smooth no matter the year. Instead of tweaking it each time, let it adapt on its own when faced with different dates across decades.

difficulty: hard
category: Feature
tags: [node, express, dates, algorithms]
parser_name: pytest
