diff --git a/server/routes/advanced.js b/server/routes/advanced.js
index 0144b18..cab5a00 100644
--- a/server/routes/advanced.js
+++ b/server/routes/advanced.js
@@ -1 +1,95 @@
-const express=require('express');const {requireNumbers}=require('../middleware/validate');const {factorial,fibonacci,gcd,lcm,primesUpTo}=require('../services/calculator');const router=express.Router();router.get('/factorial',requireNumbers(['n']),(req,res)=>{const n=Number(req.query.n);try{res.json({result:factorial(n)})}catch(e){res.status(400).json({error:e.message})}});router.get('/fibonacci',requireNumbers(['n']),(req,res)=>{const n=Number(req.query.n);try{res.json({result:fibonacci(n)})}catch(e){res.status(400).json({error:e.message})}});router.get('/gcd',requireNumbers(['a','b']),(req,res)=>{const a=Number(req.query.a);const b=Number(req.query.b);res.json({result:gcd(a,b)})});router.get('/lcm',requireNumbers(['a','b']),(req,res)=>{const a=Number(req.query.a);const b=Number(req.query.b);res.json({result:lcm(a,b)})});router.get('/primes',requireNumbers(['n']),(req,res)=>{const n=Number(req.query.n);res.json({result:primesUpTo(n)})});module.exports=router;
+const express = require('express');
+const { requireNumbers } = require('../middleware/validate');
+const { factorial, fibonacci, gcd, lcm, primesUpTo, linearQuantiles, tukeyQuantiles } = require('../services/calculator');
+
+const router = express.Router();
+
+router.get('/factorial', requireNumbers(['n']), (req, res) => {
+  const n = Number(req.query.n);
+  try {
+    res.json({ result: factorial(n) });
+  } catch (e) {
+    res.status(400).json({ error: e.message });
+  }
+});
+
+router.get('/fibonacci', requireNumbers(['n']), (req, res) => {
+  const n = Number(req.query.n);
+  try {
+    res.json({ result: fibonacci(n) });
+  } catch (e) {
+    res.status(400).json({ error: e.message });
+  }
+});
+
+router.get('/gcd', requireNumbers(['a', 'b']), (req, res) => {
+  const a = Number(req.query.a);
+  const b = Number(req.query.b);
+  res.json({ result: gcd(a, b) });
+});
+
+router.get('/lcm', requireNumbers(['a', 'b']), (req, res) => {
+  const a = Number(req.query.a);
+  const b = Number(req.query.b);
+  res.json({ result: lcm(a, b) });
+});
+
+router.get('/primes', requireNumbers(['n']), (req, res) => {
+  const n = Number(req.query.n);
+  res.json({ result: primesUpTo(n) });
+});
+
+// New endpoint: quantiles
+router.post('/quantiles', (req, res) => {
+  const body = req.body || {};
+  const numbers = body.numbers;
+  let method = body.method || 'tukey';
+  let percentiles = body.percentiles || [25, 50, 75];
+
+  // Validate numbers array
+  if (!Array.isArray(numbers) || numbers.length < 2) {
+    res.status(400).json({ error: 'numbers' });
+    return;
+  }
+  for (const n of numbers) {
+    if (typeof n !== 'number' || !Number.isFinite(n)) {
+      res.status(400).json({ error: 'numbers' });
+      return;
+    }
+  }
+
+  // Validate method
+  method = String(method).toLowerCase();
+  if (method !== 'tukey' && method !== 'linear') {
+    res.status(400).json({ error: 'method' });
+    return;
+  }
+
+  // Validate percentiles
+  if (!Array.isArray(percentiles) || percentiles.length === 0) {
+    res.status(400).json({ error: 'percentiles' });
+    return;
+  }
+  for (const p of percentiles) {
+    if (!Number.isInteger(p) || p < 0 || p > 100) {
+      res.status(400).json({ error: 'percentiles' });
+      return;
+    }
+  }
+
+  let result;
+  try {
+    if (method === 'tukey') {
+      result = tukeyQuantiles(numbers, percentiles);
+    } else {
+      result = linearQuantiles(numbers, percentiles);
+    }
+  } catch (e) {
+    res.status(400).json({ error: 'compute' });
+    return;
+  }
+
+  res.json(result);
+});
+
+module.exports = router;
diff --git a/server/services/calculator.js b/server/services/calculator.js
index fb5ba03..aa49f97 100644
--- a/server/services/calculator.js
+++ b/server/services/calculator.js
@@ -1 +1,55 @@
-function factorial(n){if(n<0)throw new Error('neg');let r=1;for(let i=2;i<=n;i++)r*=i;return r;}function fibonacci(n){if(n<0)throw new Error('neg');let a=0,b=1;for(let i=0;i<n;i++){[a,b]=[b,a+b];}return a;}function gcd(a,b){a=Math.abs(a);b=Math.abs(b);while(b){[a,b]=[b,a%b];}return a;}function lcm(a,b){if(a===0||b===0)return 0;return Math.abs(a*b)/gcd(a,b);}function prime(n){if(n<2)return false;for(let i=2;i*i<=n;i++){if(n%i===0)return false;}return true;}function primesUpTo(n){const out=[];for(let i=2;i<=n;i++){if(prime(i))out.push(i);}return out;}function mean(arr){return arr.length? arr.reduce((a,b)=>a+b,0)/arr.length:0;}function variance(arr){if(arr.length<2)return 0;const m=mean(arr);return arr.reduce((s,x)=>s+(x-m)*(x-m),0)/(arr.length-1);}function stddev(arr){return Math.sqrt(variance(arr));}module.exports={factorial,fibonacci,gcd,lcm,prime,primesUpTo,mean,variance,stddev};
+function factorial(n){if(n<0)throw new Error('neg');let r=1;for(let i=2;i<=n;i++)r*=i;return r;}
+function fibonacci(n){if(n<0)throw new Error('neg');let a=0,b=1;for(let i=0;i<n;i++){[a,b]=[b,a+b];}return a;}
+function gcd(a,b){a=Math.abs(Math.trunc(a));b=Math.abs(Math.trunc(b));while(b){[a,b]=[b,a%b];}return a;}
+function lcm(a,b){a=Math.trunc(a);b=Math.trunc(b);if(a===0||b===0)return 0;return Math.abs(a*b)/gcd(a,b);}
+function prime(n){if(n<2)return false;for(let i=2;i*i<=n;i++){if(n%i===0)return false;}return true;}
+function primesUpTo(n){const out=[];for(let i=2;i<=n;i++){if(prime(i))out.push(i);}return out;}
+
+// Basic stats helpers reused by tasks
+function mean(arr){return arr.length? arr.reduce((a,b)=>a+b,0)/arr.length:0;}
+function median(arr){if(!arr.length)return 0;const a=arr.slice().sort((x,y)=>x-y);const m=Math.floor(a.length/2);return a.length%2? a[m] : (a[m-1]+a[m])/2;}
+function variance(arr,ddof=1){const n=arr.length; if(n===0) return 0; const m=mean(arr); const ss=arr.reduce((s,x)=>s+(x-m)*(x-m),0); const denom=n-ddof; if(denom<=0) return Infinity; return ss/denom;}
+function stddev(arr,ddof=1){return Math.sqrt(variance(arr,ddof));}
+
+// Quantile utilities
+function linearQuantiles(numbers, percentiles){
+  const a = numbers.slice().sort((x,y)=>x-y);
+  const n = a.length;
+  const out = {};
+  for(const p of percentiles){
+    const pos = (p/100)*(n-1);
+    const lo = Math.floor(pos);
+    const hi = Math.ceil(pos);
+    if(lo===hi){ out[String(p)] = a[lo]; }
+    else{
+      const w = pos - lo;
+      out[String(p)] = a[lo] + w*(a[hi]-a[lo]);
+    }
+  }
+  return out;
+}
+
+function tukeyQuantiles(numbers, percentiles){
+  const a = numbers.slice().sort((x,y)=>x-y);
+  const n = a.length;
+  const result = {};
+  // Compute Q2 (median) once
+  const m2 = median(a);
+  const mid = Math.floor(n/2);
+  const lower = (n%2===1) ? a.slice(0, mid) : a.slice(0, mid); // for even, first half; for odd, exclude median
+  const upper = (n%2===1) ? a.slice(mid+1) : a.slice(mid);
+  const q1 = median(lower);
+  const q3 = median(upper);
+  for(const p of percentiles){
+    if(p===25) result['25']=q1;
+    else if(p===50) result['50']=m2;
+    else if(p===75) result['75']=q3;
+    else {
+      // Fallback to linear interpolation for non-(25,50,75)
+      Object.assign(result, linearQuantiles(a, [p]));
+    }
+  }
+  return result;
+}
+
+module.exports={factorial,fibonacci,gcd,lcm,prime,primesUpTo,mean,median,variance,stddev,linearQuantiles,tukeyQuantiles};
