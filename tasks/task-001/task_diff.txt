diff --git a/server/middleware/validate.js b/server/middleware/validate.js
index a1d95b8..c254b37 100644
--- a/server/middleware/validate.js
+++ b/server/middleware/validate.js
@@ -1 +1,55 @@
-function requireNumbers(keys){return function(req,res,next){for(const k of keys){const v=Number(req.query[k]);if(Number.isNaN(v)){res.status(400).json({error:k});return;}}next();};}module.exports={requireNumbers};
+function requireNumbers(keys) {
+  return function (req, res, next) {
+    for (const k of keys) {
+      const raw = req.query[k];
+      const v = Number(raw);
+      if (raw === undefined || Number.isNaN(v) || !Number.isFinite(v)) {
+        res.status(400).json({ error: k });
+        return;
+      }
+    }
+    next();
+  };
+}
+
+function requireIntegers(keys) {
+  return function (req, res, next) {
+    for (const k of keys) {
+      const raw = req.query[k];
+      if (raw === undefined) {
+        res.status(400).json({ error: k });
+        return;
+      }
+      const v = Number(raw);
+      if (!Number.isFinite(v) || !Number.isInteger(v)) {
+        res.status(400).json({ error: k });
+        return;
+      }
+    }
+    next();
+  };
+}
+
+function requireNumberArrayBody(field, options = {}) {
+  const { allowEmpty = false } = options;
+  return function (req, res, next) {
+    const arr = req.body && req.body[field];
+    if (!Array.isArray(arr)) {
+      res.status(400).json({ error: field });
+      return;
+    }
+    if (!allowEmpty && arr.length === 0) {
+      res.status(400).json({ error: field });
+      return;
+    }
+    for (const n of arr) {
+      if (typeof n !== 'number' || !Number.isFinite(n)) {
+        res.status(400).json({ error: field });
+        return;
+      }
+    }
+    next();
+  };
+}
+
+module.exports = { requireNumbers, requireIntegers, requireNumberArrayBody };
diff --git a/server/routes/advanced.js b/server/routes/advanced.js
index 0144b18..366ed26 100644
--- a/server/routes/advanced.js
+++ b/server/routes/advanced.js
@@ -1 +1,99 @@
-const express=require('express');const {requireNumbers}=require('../middleware/validate');const {factorial,fibonacci,gcd,lcm,primesUpTo}=require('../services/calculator');const router=express.Router();router.get('/factorial',requireNumbers(['n']),(req,res)=>{const n=Number(req.query.n);try{res.json({result:factorial(n)})}catch(e){res.status(400).json({error:e.message})}});router.get('/fibonacci',requireNumbers(['n']),(req,res)=>{const n=Number(req.query.n);try{res.json({result:fibonacci(n)})}catch(e){res.status(400).json({error:e.message})}});router.get('/gcd',requireNumbers(['a','b']),(req,res)=>{const a=Number(req.query.a);const b=Number(req.query.b);res.json({result:gcd(a,b)})});router.get('/lcm',requireNumbers(['a','b']),(req,res)=>{const a=Number(req.query.a);const b=Number(req.query.b);res.json({result:lcm(a,b)})});router.get('/primes',requireNumbers(['n']),(req,res)=>{const n=Number(req.query.n);res.json({result:primesUpTo(n)})});module.exports=router;
+const express = require('express');
+const { requireNumbers, requireIntegers, requireNumberArrayBody } = require('../middleware/validate');
+const { factorial, fibonacci, gcd, lcm, primesUpTo, primesInRange, mean, median, mode, variance, stddev } = require('../services/calculator');
+
+const router = express.Router();
+
+router.get('/factorial', requireIntegers(['n']), (req, res) => {
+  const n = Number(req.query.n);
+  try {
+    res.json({ result: factorial(n) });
+  } catch (e) {
+    res.status(400).json({ error: e.message });
+  }
+});
+
+router.get('/fibonacci', requireIntegers(['n']), (req, res) => {
+  const n = Number(req.query.n);
+  try {
+    res.json({ result: fibonacci(n) });
+  } catch (e) {
+    res.status(400).json({ error: e.message });
+  }
+});
+
+router.get('/gcd', requireIntegers(['a', 'b']), (req, res) => {
+  const a = Number(req.query.a);
+  const b = Number(req.query.b);
+  res.json({ result: gcd(a, b) });
+});
+
+router.get('/lcm', requireIntegers(['a', 'b']), (req, res) => {
+  const a = Number(req.query.a);
+  const b = Number(req.query.b);
+  res.json({ result: lcm(a, b) });
+});
+
+router.get('/primes', requireIntegers(['n']), (req, res) => {
+  const n = Number(req.query.n);
+  const startRaw = req.query.start;
+  const fmt = String(req.query.format || 'json').toLowerCase();
+
+  let start;
+  if (startRaw !== undefined) {
+    const sv = Number(startRaw);
+    if (!Number.isInteger(sv)) {
+      res.status(400).json({ error: 'start' });
+      return;
+    }
+    start = sv;
+  } else {
+    start = 2;
+  }
+
+  if (start < 2 || start > n) {
+    res.status(400).json({ error: 'range' });
+    return;
+  }
+
+  const primes = start === 2 ? primesUpTo(n) : primesInRange(start, n);
+
+  if (fmt === 'csv') {
+    const lines = ['prime', ...primes.map((p) => String(p))].join('\n');
+    res.setHeader('Content-Type', 'text/csv');
+    res.status(200).send(lines);
+  } else {
+    res.json({ result: primes });
+  }
+});
+
+router.post('/stats', requireNumberArrayBody('numbers'), (req, res) => {
+  const numbers = req.body.numbers;
+  let ddof = 1;
+  if (req.body.ddof !== undefined) {
+    const v = Number(req.body.ddof);
+    if (!Number.isFinite(v) || !Number.isInteger(v)) {
+      res.status(400).json({ error: 'ddof' });
+      return;
+    }
+    ddof = v;
+  }
+
+  if (numbers.length - ddof <= 0) {
+    res.status(400).json({ error: 'ddof' });
+    return;
+  }
+
+  const m = mean(numbers);
+  const med = median(numbers);
+  const mo = mode(numbers);
+  const vari = variance(numbers, ddof);
+  if (!Number.isFinite(vari)) {
+    res.status(400).json({ error: 'ddof' });
+    return;
+  }
+  const sd = stddev(numbers, ddof);
+  res.json({ mean: m, median: med, mode: mo, variance: vari, stddev: sd });
+});
+
+module.exports = router;
diff --git a/server/services/calculator.js b/server/services/calculator.js
index fb5ba03..2a31e5a 100644
--- a/server/services/calculator.js
+++ b/server/services/calculator.js
@@ -1 +1,110 @@
-function factorial(n){if(n<0)throw new Error('neg');let r=1;for(let i=2;i<=n;i++)r*=i;return r;}function fibonacci(n){if(n<0)throw new Error('neg');let a=0,b=1;for(let i=0;i<n;i++){[a,b]=[b,a+b];}return a;}function gcd(a,b){a=Math.abs(a);b=Math.abs(b);while(b){[a,b]=[b,a%b];}return a;}function lcm(a,b){if(a===0||b===0)return 0;return Math.abs(a*b)/gcd(a,b);}function prime(n){if(n<2)return false;for(let i=2;i*i<=n;i++){if(n%i===0)return false;}return true;}function primesUpTo(n){const out=[];for(let i=2;i<=n;i++){if(prime(i))out.push(i);}return out;}function mean(arr){return arr.length? arr.reduce((a,b)=>a+b,0)/arr.length:0;}function variance(arr){if(arr.length<2)return 0;const m=mean(arr);return arr.reduce((s,x)=>s+(x-m)*(x-m),0)/(arr.length-1);}function stddev(arr){return Math.sqrt(variance(arr));}module.exports={factorial,fibonacci,gcd,lcm,prime,primesUpTo,mean,variance,stddev};
+function factorial(n) {
+  if (n < 0) throw new Error('neg');
+  let r = 1;
+  for (let i = 2; i <= n; i++) r *= i;
+  return r;
+}
+
+function fibonacci(n) {
+  if (n < 0) throw new Error('neg');
+  let a = 0,
+    b = 1;
+  for (let i = 0; i < n; i++) {
+    [a, b] = [b, a + b];
+  }
+  return a;
+}
+
+function gcd(a, b) {
+  a = Math.abs(Math.trunc(a));
+  b = Math.abs(Math.trunc(b));
+  while (b) {
+    [a, b] = [b, a % b];
+  }
+  return a;
+}
+
+function lcm(a, b) {
+  a = Math.trunc(a);
+  b = Math.trunc(b);
+  if (a === 0 || b === 0) return 0;
+  return Math.abs(a * b) / gcd(a, b);
+}
+
+function prime(n) {
+  if (n < 2) return false;
+  for (let i = 2; i * i <= n; i++) {
+    if (n % i === 0) return false;
+  }
+  return true;
+}
+
+function primesUpTo(n) {
+  const out = [];
+  for (let i = 2; i <= n; i++) {
+    if (prime(i)) out.push(i);
+  }
+  return out;
+}
+
+function primesInRange(start, n) {
+  const out = [];
+  for (let i = Math.max(2, start); i <= n; i++) {
+    if (prime(i)) out.push(i);
+  }
+  return out;
+}
+
+function mean(arr) {
+  return arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;
+}
+
+function median(arr) {
+  if (!arr.length) return 0;
+  const a = arr.slice().sort((x, y) => x - y);
+  const m = Math.floor(a.length / 2);
+  return a.length % 2 ? a[m] : (a[m - 1] + a[m]) / 2;
+}
+
+function mode(arr) {
+  if (!arr.length) return null;
+  const freq = new Map();
+  for (const x of arr) freq.set(x, (freq.get(x) || 0) + 1);
+  let max = 0;
+  for (const c of freq.values()) if (c > max) max = c;
+  const candidates = Array.from(freq.entries())
+    .filter(([, c]) => c === max)
+    .map(([v]) => v)
+    .sort((a, b) => a - b);
+  if (candidates.length === 1) return candidates[0];
+  return median(candidates);
+}
+
+function variance(arr, ddof = 1) {
+  const n = arr.length;
+  if (n === 0) return 0;
+  const m = mean(arr);
+  const ss = arr.reduce((s, x) => s + (x - m) * (x - m), 0);
+  const denom = n - ddof;
+  if (denom <= 0) return Infinity;
+  return ss / denom;
+}
+
+function stddev(arr, ddof = 1) {
+  return Math.sqrt(variance(arr, ddof));
+}
+
+module.exports = {
+  factorial,
+  fibonacci,
+  gcd,
+  lcm,
+  prime,
+  primesUpTo,
+  primesInRange,
+  mean,
+  median,
+  mode,
+  variance,
+  stddev
+};
